# 📌 Contents

### 📌 오해: 객체 지향은 실세계의 모방이 목표다.

- **실세계의 모방**이라는 개념은 비현실적이다.
- 오히려 새로운 세계를 창조하는 것과 가깝다.
- 하지만, 이에 대한 비유가 OOP의 이해와 학습에 효과적이기에 사용한다.

<br/>

### 📌 사실: 객체 지향은 역할, 책임, 협력으로 이루어진다.

- 객체는 서로 요청과 응답의 방식으로 **협력**한다.
- 객체들은 협력 과정에서 각자의 **역할**을 담당한다.
- 역할을 맡은 객체는 그에 해당하는 **책임**을 져야 한다.

<br/>

### 📌 사실: 객체는 협력, 자율의 특성을 가진다.

- 객체는 다른 객체와의 요청과 응답을 충분히 협력적으로 해야 한다.
- 객체는 자신이 스스로 판단하고 해동하는 자율적인 존재다.
- 이를 위해 객체는 상태와 행동을 지니고, 메시지와 메서드를 분리한다.

<br/>

### 📌 오해: 객체 지향에서 클래스는 가장 중요하다.

- 훌륭한 객체지향 설계자는 메시지를 주고받는 객체의 관점으로 생각해야 한다.
- 클래스는 객체들의 협력 관계를 코드로 옮기는 도구에 불과하다.
- 핵심은 책임을 수행하는 역할 간의 협력을 유연하고 견고하게 구축하는 것이다.

<br/>

# ❓ Questions

### ❓ 객체 지향의 철학은 무엇일까?

```
객체 지향은 결국 기존 패러다임의 추상화가 추가된 버전입니다.
쭉 늘어놓은 절차적 프로그래밍에서 프로시저로 구분한 구조적 프로그래밍이 나온 것처럼요.

상태와 행동, 쉽게 말하면 변수와 함수를 함께 가진 객체는 어쩌면 당연한 발전입니다.
그렇다면 객체 지향은 타 패러다임과 비슷한 경향인데 왜 유독 많이 사용되는 것일까요?

우리는 추상화를 하게 되면 다른 곳에서 구현된 것은 신경 쓰지 않아도 됩니다.
그렇습니다. 객체란 프로그램을 나눠주는 적당한 단위였던 것입니다.
예를 들면 만약 모니터가 꺼져있다면(상태) 마우스 클릭(행위)을 인식하지 않아도 됩니다.
하지만 객체가 없다면 모니터가 어떤 상태이든 마우스는 항상 동작해야 합니다.

정리하자면 객체 지향의 철학은 "상태와 행동을 가진 객체 간의 협력"입니다.
더 높게 가자면 "프로그램을 위한 추상화"라고도 생각할 수 있습니다.
```

<br/>

### ❓ 객체 지향의 중요한 내용이라 나와 있는 부분은 왜 중요한 것일까?

```
책의 31p에서는 밑에서 순번을 적은 내용들이 중요한 내용이라고 나옵니다.
객체 지향에서 이는 무엇을 의미하길래 중요하다는 걸까요?

1. 여러 객체가 동일한 역할을 수행할 수 있다.
2. 역할은 대체 가능성을 의미한다.

여기에 Student라는 클래스가 있습니다. 이 역할은 사람 A, B... 여럿이 할 수 있습니다.
이는 누구나 들어봤을 법한 "상속"이라는 방법으로 이루어지게 됩니다.

여기에 또 void readBook(Student A, Book B)라는 함수가 있습니다.
그렇다면 Student를 상속받은 ComputerEngineeringMajorStudent는 함수로 들어갈 수 있을까요?
네 맞습니다. Student라는 역할을 가지고 있기 때문에 대체 가능한 것입니다.

3. 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있다.
4. 하나의 객체가 동시에 여러 역할을 수행할 수 있다.

위의 두 문장은 "다형성"과 관련되어 있습니다.
이는 한자 그대로 "어떤 객체의 속성이나 기능이 상황에 따라 여러 형태를 띤다"는 것입니다.

여기에 Monitor 객체가 있습니다. 마우스 클릭이라는 메시지가 왔는데 어떻게 해야할까요?
물론 당연히 처리해야겠죠. 그런데 알고 보니 모니터가 꺼져있습니다.
그렇다면 저는 "미안 다음번에 다시 클릭해 줘" 함수를 실행해 주면 되겠네요.
```

<br/>

### ❓ 프로시저 호출에 대한 실행 코드란 무슨 뜻일까?

```
먼저 책에서 이 개념이 나올 때 대립구조가 함께 나옵니다.
이는 절차 지향(컴파일 타임) vs 객체 지향(런타임) 입니다.

왜 "프로시저 호출에 대한 실행 코드"는 절차 지향은 컴파일, 객체 지향은 런타임에 결정될까요?
어려운 말이 나왔으니 단순화하자면 컴파일은 준비 시간, 런타임은 실행 시간입니다.
그리고 여기서 프로시저는 함수로 대체 가능하니 "함수를 쓰는 실행 코드"라고 생각해 봅시다.

그렇다면 단순하네요. Monitor 예제를 다시 보자면 당연히 객체 지향은 런타임에 정해질 테죠.
모니터의 켜짐 유무에 따라 마우스 클릭에 대한 함수는 달라질 테니까요.

그러면 또 생기는 의문이 있습니다. 
A: "C언어는 절차 지향 언어인가요?"
B: "네, 맞습니다"
A: "그럼 C언어에서 n이라는 변수에 scanf로 받아서 if문으로 분기해 함수를 고르면 이는 뭐죠?"
B: "..."

완벽하게 책의 오류를 찾았다고 생각하셨나요? 우리가 틀렸는지 좀 더 고민해 봅시다.
이에 대한 고민은 어쩌면 단순할지도 모릅니다. 우리가 완벽한 정사각형은 그릴 수 없는 것처럼요.
패러다임과 언어를 동일시하면 안 된다는 의미입니다.

C언어는 동적인 부분도 있어 값 변경도 되고 이를 통한 프로그래밍도 가능하다는 것이죠.
하지만 패러다임 자체로 본다면 맨 처음의 주장이 일리가 있습니다.
따라서, 여기서는 세세한 예시보다는 구조와 맥락을 보는 것이 더 편할 것 같습니다.
```

<br/>
