# 📌 Contents

### 📌 추상화란?

```
어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해
특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.

복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다.
이 모든 차원에서 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는 것이다.
```

- 첫 번째 차원은 구체적인 사물 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것이다.
- 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것이다.

<br/>

### 📌 타입이란?

- 타입이란 다양한 사물이나 객체에 적용할 수 있는 아이디어를 의미한다.
- 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다.<br/>
  타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.
- 타입은 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터다.<br/>
  이 분류는 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.

```
타입 간에는 일반화/특수화 관계가 존재할 수 있다. 이는 슈퍼타입과 서브타입이라고도 표현한다.
서브타입은 슈퍼타입의 행위적 호환성을 만족하여 완벽하게 대체할 수 있어야 한다.
이는 우리가 잘 알고 있는 클래스와 상속이라는 기술로 구현이 된다.
```

<br/>

### 📌 타입은 추상화다

- 원래는 앨리스 객체는 시간에 따라 바뀌는 “동적 모델”이다.<br/>
  하지만 타입은 앨리스의 상태를 시간과 무관한 “정적 모델”로 만들어준다.<br/>
  즉, 앨리스의 중요한 정보를 강조하려 시간을 제거하는 타입은 추상화다.
- 즉, 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화하는 방법이다.
- 타입은 객체지향 언어에서 클래스를 이용해 구현된다.

<br/>

![typeisabstract](https://github.com/BOOK-SCAN/object-oriented-facts-and-misunderstandings/assets/68336833/336bcb28-77fd-4cb1-a9be-8f9bce74ff72)


# ❓ Questions

### ❓ 분류 시에 교집합에 있는 객체는 어떻게 해야 할까?

```
책에서는 트럼프 인간에 대해서 트럼프라는 타입의 서브 타입으로 지정합니다.
하지만 만약 인간이라는 타입도 이미 정의했다면 어떤가요?
트럼프 인간은 트럼프이면서 인간이니까 두 개의 타입의 교집합에 있습니다.
이럴 때 트럼프 인간은 어디로 가야 할까요?

먼저 1장으로 돌아가 봅시다. "하나의 객체가 동시에 여러 역할을 수행할 수 있다."
즉, 교집합이고 두 개의 타입 집합이 유의미하다면 여러 역할을 가지면 되는 겁니다.

그렇다면 우리는 어떻게 역할을 여러 개 받을 수 있을까요?
이를 위해 이미 다중 상속을 지원하는 언어들도 있습니다. (물론 문제도 있습니다.)
하지만 Java의 경우 클래스의 다중 상속을 제한합니다.
이에 대한 이유는 구현체 간의 충돌로 문제가 생기기 때문입니다.

그렇다면 Java는 어떻게 다중 상속을 할 수 있는지 코드로 확인해 볼까요?
```

```java
public interface Trump {
    // trump의 행위들
}
public interface Human {
    // human의 행위들
}

public class TrumpHuman implements Trump, Human {
		// trump와 human의 행위들 구현
}
```

```
구현체 간의 충돌이 나서 문제가 생긴다면 무엇을 고쳐야 할까요?
구현체들이 충돌이 나지 않게 하면 됩니다!

너무 당연한거지만 더 자세하게 말하면 좀 색다를 수도 있을 겁니다.
구현을 하지 않고 상속을 받으면 됩니다!

네, 구현을 하지 않으면 구현체가 없으니 충돌도 안나고 필요에 맞게 구현하면 됩니다.
그래서 Java는 인터페이스를 활용하여 다중 상속을 지원하고 있습니다.
```

<br/>

### ❓SRP와 다중 상속은 양립할 수 있는가?

```
객체지향의 5대 원칙, SOLID 원칙이 있습니다.
이 중 SRP(Single Responsibility Principle)은 단일 책임 원칙입니다.

그런데 좀 이상하지 않나요? 위에서 다중 상속은 분명 여러 역할을 받는 거잖아요?
그렇다면 역할에 따른 책임도 가질테고 그러면 원칙에 위배되는 거 아닐까요?

이에 대해 SOLID를 창시한 로버트C 마틴이 SRP를 새롭게 정의하게 됩니다.
"하나의 모듈은 하나의 액터에 대해서만 책임져야 한다"
액터는 시스템이 동일한 방식으로 변경되기를 원하는 사용자 집단을 의미합니다.

좀 더 쉽게 예시를 보면서 생각해볼까요?
앨리스 사용자는 겁먹지 않기 위해 트럼프 인간을 트럼프로 보길 원했어요.
하지만 저는 한글에서는 뒷 단어가 중요하다는 것을 국어시간에 배웠거든요.
그래서 저는 트럼프 인간을 인간으로 보길 원했습니다.

그러다보니 앨리스는 트럼프 인간의 두께를 맘대로 줄이고 싶어하고,
저는 밥 먹기와 같은 행위를 추가하려고 했죠.
여기서 저와 앨리스는 다른 액터입니다. 서로 한 객체를 다르게 조정하려고 하죠.

하지만, 저와 앨리스 둘다 같은 요구 사항으로 트럼프 인간을 대한다면
트럼프이면서 인간의 모습에 둘다 만족을 한다면 둘은 하나의 액터가 됩니다.
즉, 다중 상속을 받더라도 하나의 액터가 되어 SRP를 만족시킬 수 있다는 거죠!
```

<br/>
