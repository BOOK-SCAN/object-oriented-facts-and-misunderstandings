# 📌 역할, 책임, 협력

- 인간세계와 마찬가지로 협력이 객체의 행동방식을 결정한다
- 개별적인 객체의 행동이나 상태가 아니라 객체들 간의 협력에 집중하라

### 📌 협력

- 다수의 요청과 응답으로 구성되며 전체적으로 협력은 다수의 연쇄적인 요청과 응답의 흐름으로 구성.
  - 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의

### 📌 책임

- 어떤 대상에 대한 요청은 그 대상이 요청을 처리할 책임이 있음을 암시.
- ‘객체가 무엇을 알고 있는가(knowing)’ + ‘무엇을 할 수 있는가(doing)’
- 하는 것(doing)
  - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
  - 다른 객체의 행동을 시작시키는 것
  - 다른 객체의 활동을 제어하고 조절하는 것
- 아는 것(knowing)
  - 개인적인 정보에 관해 아는 것
  - 관련된 객체에 관해 아는 것
  - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

⇒ 책임 : ‘객체의 외부에 제공해 줄 수 있는 정보(knowing)’ + ‘외부에 제공해 줄 수 있는 서비스(doing)’

- 메시지를 통해 두 객체가 주어진 책임을 수행하도록 요청을 보낸다
- 송신자 : 메세지 전송 → 협력을 요청하는 객체
- 수신자 : 메세지 받음 → 요청을 처리하는 객체

### 📌 역할

- 객체가 협력 안에서 수행하는 역할은 객체가 수행하는 책임의 집합이다
- 재사용 가능 & 유연한 객체지향 설계를 낳음
- 협력 내에서 다른 객체로 대체할 수 있음을 나타냄
  - 역할을 대체할 수 있는 객체는 동일한 메세지를 이해할 수 있는 객체로 한정
- 단순성, 유연성, 재사용성을 뒷받침함
- 역할로 인해 협력을 추상화할 수 있다.
- 역할은 협력 안에서 구체적인 객체로 대체될 수 있는 추상적인 협력자. → 다른 객체가 대체가능
- 역할의 대체 가능성은 행위 호환성을 의미하고, 행위 호환성은 동일한 책임의 수행을 의미한다.

### 📌객체지향 설계

#### 하는 법

협력 설계 → 객체들이 주고받을 요청과 응답의 흐름을 결정한다 → 요청과 응답의 흐름은 책임이 됨(책임은 객체가 외부에 제공하게 될 행동이 됨) → 행동을 수행하는 데 필요한 데이터 고민 → 클래스 구현 방법 결정

- **객체지향 시스템에서 가장 중요한 것은 충분히 자율적인 동시에 충분히 협력적인 객체를 창조하는 것**
  - 위 목표를 달성하기 위해서는 객체를 충분히 협력적으로 만든 후에 협력이라는 문맥 안에서 객체를 충분히 자율적으로 만드는 것

#### 기법

- 책임-주도 설계
  - 객체의 책임을 중심으로 시스템을 구축
- 디자인 패턴
  - 반복적으로 발생하는 문제와 그 문제애 대한 해법의 쌍
- 테스트-주도 개발
  - 실패하는 테스트를 작성하고, 테스트를 통과하는 가장 간단한 코드를 작성한 후, 리팩터링을 통해 중복 제거

# ❓ Questions

### ❓ 책임과 메시지는 다르지(?)

p.117 ~ 118 **_한 가지 주의할 점은 책임과 메시지의 수준이 같지 않다._**

협력 > 책임 → 요청을 수신하는 한 쪽의 객체 관점에서 무엇을 할 수 있는지 나열

        - 객체가 협력에 참여하기 위해 수행해야 하는 행위를 상위 수준(?)에서 개략적으로 서술한 것

        > 메시지 → 두 객체(송신자 & 수신자) 사이의 상호작용 강조

        - 책임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변환할 때 하나의 책임이 여러 메시지로 분할되는 것이 일반적이다.

p. 126 **_메시지 == 책임_**

동일한 **역할** 수행 가능 = 해당 객체들이 동일한 **책임의 집합**을 수행할 수 있다는 것

동일한 역할을 수행하는 객체들이 동일한 메시지를 수신할 수 있기 때문에 →

동일한 책임을 수행할 수 있음

⇒ 협력 ← 역할← 책임
← 메세지
