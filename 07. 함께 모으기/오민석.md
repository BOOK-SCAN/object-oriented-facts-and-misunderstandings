# 📌 Contents

### 📌 객체 지향의 세 가지 관점

- 개념: 사용자가 도메인을 바라본 개념과 개념들 사이의 관계를 최대한 표현한다.
- 명세: 객체의 인터페이스, 즉 협력을 위해 무엇을 할 수 있는가를 표현한다.
- 구현: 객체의 책임 수행 방식에 초점을 맞추어 속성과 메서드를 추가한다.

<br/>

### 📌 관점을 통한 개발

- 개념: 상황 내에서 필요한 객체를 인식하고 관계를 정의한다.
- 명세: 상황 내에서 필요한 메시지를 정의하고 객체를 선택한다.</br>
  명세: 메시지의 이름과 필요한 요청, 응답 인자도 함께 정의한다.
- 구현: 인터페이스를 구현하기 위해 속성과 메서드를 추가한다.

<br/>

### 📌 세 가지 관점을 담은 클래스

- 개념: 클래스의 이름은 도메인에서 가져온 객체들을 나타낸다.
- 명세: 클래스의 공용 인터페이스는 다른 객체들이 접근할 수 있는 방식을 나타낸다.
- 구현: 클래스의 내부 구현은 외부 객체에 영향을 받지 않고 수행 방식을 나타난다.

<br/>

# ❓ Questions

### ❓ 언제 참조로 담고 언제 인자로 담아야 할까?

```
지난 챕터에서 객체 내부에 참조를 담아야 한다는 것을 배웠습니다.
예를 들면 앨리스 객체가 물병 객체를 참조로 담는 것입니다.

아니라면 객체의 메서드 내에 인자를 담아야 한다는 것을 배웠습니다.
바리스타는 makeCoffe 함수에 menuItem을 담고 있는 것처럼요.

언제는 링크고 언제는 인자일까요?
그래서 우리는 객체들의 관계를 확실하게 정의해야 합니다.
참조는 객체 간의 관계가 더 강해 직접 의존해야 하는 상황에 해당합니다.
인자는 객체 간의 결합을 느슨하게 유지할 때 사용합니다.

단순히 포함관계나 한 객체의 일부인지를 판단하여 진행해도 됩니다.
하지만 물병 객체의 경우에는 이보다는 물병이 앨리스에게 강하게 의존합니다.
그래서 둘은 참조를 통해 연결이 되어 있습니다.
따라서 객체들 간의 연결이나 의존성을 먼저 따지고 이를 기반으로 선택해야 합니다.
```

<br/>

### ❓ MenuItem의 메서드 이름은 cost가 어울릴까?

```
name을 가져오는 메서드의 이름은 getName입니다.
price를 가져오는 메서드의 이름은 왜 cost일까요?

객체 지향에서 getter와 setter는 일정한 이름의 양식을 가집니다.
그래서 price 또한 getPrice가 더 나은 선택이라고 합니다.
그럼 이를 Java 코드로 어떻게 작성되는지 알아봅시다.
```

```java
public MenuItem {
		private int price;

		public int getPrice() {
				return this.price;
		}
}

@Getter
public MenuItem {
		private int price;
}
```

```
위와 같이 구현을 하면 Java에서 Getter를 구현할 수 있습니다.
밑의 코드에서 @Getter 어노테이션은 자동으로 메서드를 추가해 줍니다.
이를 잘 활용하면 더 깔끔한 클래스 구현을 할 수 있습니다.
```

<br/>
